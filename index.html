<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Localhost</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2c3e50;
            color: white;
            margin: 0;
            padding: 20px;
            overflow: hidden; /* Disable scrollbar */
        }
        
        h1 {
            color: #ecf0f1;
            margin-bottom: 20px;
        }
        
        #gameContainer {
            position: relative;
            border: 3px solid #34495e;
            background-color: #1a252f;
            margin: 20px 0;
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        
        #gameCanvas {
            display: block;
            background-color: #0f1419;
        }
        
        #chatContainer {
            width: 300px;
            display: flex;
            flex-direction: column;
            background-color: #2c3e50;
            border-radius: 5px;
            padding: 10px;
        }
        
        #leftPanel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        #playerList {
            width: 280px;
            padding: 15px;
            background-color: #34495e;
            border-radius: 5px;
            min-height: 300px;
        }
        
        #leaderboard {
            width: 280px;
            padding: 15px;
            background-color: #2c3e50;
            border-radius: 5px;
            min-height: 200px;
        }
        
        #leaderboard h3 {
            margin-top: 0;
            color: #f39c12;
            font-size: 16px;
            border-bottom: 1px solid #34495e;
            padding-bottom: 10px;
        }
        
        #leaderboardList div {
            padding: 5px 0;
            border-bottom: 1px solid #34495e;
            font-size: 14px;
            word-wrap: break-word;
        }
        
        #leaderboardList div:last-child {
            border-bottom: none;
        }
        
        #voteControls {
            text-align: center;
        }
        
        #voteControls button {
            width: 100%;
            margin: 5px 0;
            padding: 8px 16px;
            font-size: 14px;
        }
        
        #playerList h3 {
            margin-top: 0;
            color: #ecf0f1;
            font-size: 16px;
            border-bottom: 1px solid #2c3e50;
            padding-bottom: 10px;
        }
        
        #players div {
            padding: 8px 0;
            border-bottom: 1px solid #2c3e50;
            font-size: 14px;
            word-wrap: break-word;
        }
        
        #players div:last-child {
            border-bottom: none;
        }
        
        #chatMessages {
            flex: 1;
            height: 400px;
            overflow-y: auto;
            background-color: #1a252f;
            border: 1px solid #34495e;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            color: white;
            font-size: 14px;
        }
        
        .chat-message {
            margin-bottom: 5px;
            word-wrap: break-word;
        }
        
        .chat-system {
            color: #f39c12;
            font-style: italic;
        }
        
        .chat-player {
            color: #3498db;
        }
        
        #chatInput {
            width: 100%;
            padding: 8px;
            border: 1px solid #34495e;
            border-radius: 3px;
            background-color: #1a252f;
            color: white;
            font-size: 14px;
        }
        
        #chatInput:focus {
            outline: none;
            border-color: #3498db;
        }
        
        #nameModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        #nameForm {
            background-color: #2c3e50;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #34495e;
        }
        
        #nameInput {
            width: 250px;
            padding: 12px;
            margin: 15px 0;
            border: 1px solid #34495e;
            border-radius: 5px;
            background-color: #1a252f;
            color: white;
            font-size: 16px;
            text-align: center;
        }
        
        #nameInput:focus {
            outline: none;
            border-color: #3498db;
        }
        
        #joinButton {
            padding: 12px 24px;
            font-size: 16px;
            background-color: #27ae60;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }
        
        #joinButton:hover {
            background-color: #219a52;
        }
        
        #joinButton:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
        }
        
        #controls {
            margin: 20px 0;
            text-align: center;
        }
        
        #foodLegend {
            background-color: #1a252f;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            border: 1px solid #34495e;
        }
        
        #foodLegend h4 {
            margin: 0 0 8px 0;
            color: #f39c12;
            font-size: 14px;
        }
        
        .food-type {
            margin: 3px 0;
            font-size: 12px;
            color: white;
        }
        
        button {
            padding: 12px 24px;
            font-size: 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
        }
        
        #gameInfo {
            display: flex;
            gap: 30px;
            margin: 10px 0;
            font-size: 18px;
        }
        
        #status {
            margin: 10px 0;
            font-size: 16px;
            color: #e74c3c;
        }
        
        #connectionStatus {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 10px 15px;
            border-radius: 5px;
            font-weight: bold;
        }
        
        .connected {
            background-color: #27ae60;
        }
        
        .disconnected {
            background-color: #e74c3c;
        }
    </style>
</head>
<body>
    <!-- Name Modal -->
    <div id="nameModal">
        <div id="nameForm">
            <h2>üêç Snake Game Multiplayer</h2>
            <p>Nh·∫≠p t√™n c·ªßa b·∫°n ƒë·ªÉ tham gia game:</p>
            <input type="text" id="nameInput" placeholder="T√™n c·ªßa b·∫°n" maxlength="20" />
            <br>
            <button id="joinButton">Tham gia Game</button>
        </div>
    </div>

    <h1>üêç Snake Game Multiplayer</h1>
    
    <div id="connectionStatus" class="disconnected">Ch·ªù k·∫øt n·ªëi...</div>
    
    <div id="status">Ch·ªù nh·∫≠p t√™n...</div>
    
    <div id="gameContainer">
        <div id="leftPanel">
            <div id="playerList">
                <h3>Danh s√°ch ng∆∞·ªùi ch∆°i:</h3>
                <div id="players"></div>
                <div id="voteControls" style="margin-top: 15px;">
                    <button id="voteButton" disabled>Vote ƒë·ªÉ b·∫Øt ƒë·∫ßu</button>
                    <button id="startButton" disabled style="display: none;">B·∫Øt ƒë·∫ßu Game</button>
                    <button id="restartButton" style="display: none;">Ch∆°i l·∫°i</button>
                </div>
                <div id="voteStatus" style="display: none; margin-top: 10px;">
                    <div>Votes: <span id="voteCount">0</span>/<span id="totalPlayers">0</span></div>
                    <div>C·∫ßn th√™m <span id="votesNeeded">0</span> vote ƒë·ªÉ b·∫Øt ƒë·∫ßu</div>
                </div>
            </div>
            
            <div id="leaderboard">
                <h3>üèÜ B·∫£ng x·∫øp h·∫°ng:</h3>
                <div id="leaderboardList"></div>
            </div>
        </div>
        <canvas id="gameCanvas" width="1000" height="700"></canvas>
        <div id="chatContainer">
            <h4>üí¨ Chat</h4>
            <div id="chatMessages"></div>
            <input type="text" id="chatInput" placeholder="Nh·∫≠p tin nh·∫Øn..." maxlength="100" />
            <div id="foodLegend">
                <h4>üçé Lo·∫°i th·ª©c ƒÉn:</h4>
                <div class="food-type"><span style="color: #e74c3c;">üî¥ ƒê·ªè:</span> +1 ƒë·ªô d√†i</div>
                <div class="food-type"><span style="color: #ffffff;">‚ö™ Tr·∫Øng:</span> +10 ƒë·ªô d√†i</div>
                <div class="food-type"><span style="color: #9b59b6;">üü£ T√≠m:</span> TƒÉng t·ªëc 5s</div>
                <div class="food-type"><span style="color: #34495e;">‚ö´ ƒêen:</span> +20 ƒë·ªô d√†i</div>
                <div class="food-type"><span style="color: #95a5a6;">üîò X√°m:</span> Gi·∫£m t·ªëc 80% trong 5s</div>
                <div class="food-type"><span style="color: #FFFF00;">üü° V√†ng:</span> T·∫°o ra 50 th·ª©c ƒÉn</div>
            </div>
        </div>
    </div>
    
    <div id="gameInfo">
        <div>Ng∆∞·ªùi ch∆°i: <span id="playerCount">0</span></div>
        <div>T·ªïng ƒëi·ªÉm: <span id="myScore">0</span></div>
    </div>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const voteButton = document.getElementById('voteButton');
        const restartButton = document.getElementById('restartButton');
        const statusDiv = document.getElementById('status');
        const playerCountSpan = document.getElementById('playerCount');
        const myScoreSpan = document.getElementById('myScore');
        const playersDiv = document.getElementById('players');
        const leaderboardList = document.getElementById('leaderboardList');
        const connectionStatus = document.getElementById('connectionStatus');
        const nameModal = document.getElementById('nameModal');
        const nameInput = document.getElementById('nameInput');
        const joinButton = document.getElementById('joinButton');
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const voteStatus = document.getElementById('voteStatus');
        const voteCount = document.getElementById('voteCount');
        const totalPlayers = document.getElementById('totalPlayers');
        const votesNeeded = document.getElementById('votesNeeded');
        
        let socket = null;
        let myPlayerId = null;
        let myPlayerName = '';
        let gameState = null;
        
        // Snake colors for different players
        const colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', 
            '#9b59b6', '#1abc9c', '#e67e22', '#34495e'
        ];
        
        function connectWebSocket() {
            // Connect to same host and port as HTTP server
            const host = window.location.hostname;
            const port = window.location.port || '666';
            const wsUrl = `ws://${host}:${port}`;
            
            console.log('Connecting to WebSocket:', wsUrl);
            console.log('Player name:', myPlayerName);
            
            socket = new WebSocket(wsUrl);
            
            socket.onopen = function() {
                console.log('K·∫øt n·ªëi WebSocket th√†nh c√¥ng t·ªõi:', wsUrl);
                connectionStatus.textContent = 'ƒê√£ k·∫øt n·ªëi';
                connectionStatus.className = 'connected';
                statusDiv.textContent = 'ƒê√£ k·∫øt n·ªëi! Ch·ªù ng∆∞·ªùi ch∆°i kh√°c...';
                
                // Send join message with player name
                const joinMessage = {
                    type: 'join',
                    name: myPlayerName
                };
                console.log('Sending join message:', joinMessage);
                socket.send(JSON.stringify(joinMessage));
            };
            
            socket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                
                if (data.type === 'init') {
                    myPlayerId = data.player_id;
                    gameState = data.game_state;
                    updateUI();
                } else if (data.type === 'join_rejected') {
                    // Player cannot join because game is running
                    alert(data.reason);
                    statusDiv.textContent = data.reason;
                    statusDiv.style.color = '#e74c3c';
                    // Show name modal again
                    nameModal.style.display = 'flex';
                    nameInput.value = '';
                    nameInput.focus();
                } else if (data.type === 'game_state') {
                    gameState = data.game_state;
                    updateUI();
                } else if (data.type === 'vote_status') {
                    updateVoteUI(data.vote_status, data.votes);
                } else if (data.type === 'vote_needed') {
                    updateVoteUI(data.vote_status, {});
                } else if (data.type === 'chat') {
                    addChatMessage(data.player_name, data.message);
                } else if (data.type === 'system') {
                    addSystemMessage(data.message);
                }
            };
            
            socket.onclose = function() {
                console.log('WebSocket ƒë√£ ƒë√≥ng');
                connectionStatus.textContent = 'M·∫•t k·∫øt n·ªëi';
                connectionStatus.className = 'disconnected';
                statusDiv.textContent = 'M·∫•t k·∫øt n·ªëi! ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i...';
                
                // Th·ª≠ k·∫øt n·ªëi l·∫°i sau 3 gi√¢y
                setTimeout(connectWebSocket, 3000);
            };
            
            socket.onerror = function(error) {
                console.error('L·ªói WebSocket:', error);
                connectionStatus.textContent = 'L·ªói k·∫øt n·ªëi';
                connectionStatus.className = 'disconnected';
            };
        }
        
        function updateUI() {
            if (!gameState) return;
            
            playerCountSpan.textContent = gameState.player_count;
            
            // Update my score
            const mySnake = gameState.snakes.find(s => s.player_id === myPlayerId);
            if (mySnake) {
                const currentScore = mySnake.score > 0 ? ` (${mySnake.score})` : '';
                myScoreSpan.textContent = `${mySnake.total_score}${currentScore}`;
            }
            
            // Update buttons and voting
            if (gameState.game_started) {
                voteButton.style.display = 'none';
                voteStatus.style.display = 'none';
                startButton.style.display = 'none';
                if (!gameState.game_running) {
                    restartButton.style.display = 'inline-block';
                } else {
                    restartButton.style.display = 'none';
                }
            } else {
                // Show voting interface
                voteButton.style.display = 'inline-block';
                voteStatus.style.display = 'block';
                startButton.style.display = 'none';
                restartButton.style.display = 'none';
                
                // Enable/disable vote button
                const hasVoted = gameState.votes && gameState.votes[myPlayerId];
                voteButton.disabled = hasVoted || gameState.player_count === 0;
                voteButton.textContent = hasVoted ? 'ƒê√£ vote ‚úì' : 'Vote ƒë·ªÉ b·∫Øt ƒë·∫ßu';
                
                // Update vote status
                if (gameState.vote_status) {
                    voteCount.textContent = gameState.vote_status.voted_count;
                    totalPlayers.textContent = gameState.vote_status.total_players;
                    votesNeeded.textContent = gameState.vote_status.votes_needed;
                }
            }
            
            // Update status
            if (!gameState.game_started) {
                if (gameState.player_count === 0) {
                    statusDiv.textContent = 'Ch·ªù ng∆∞·ªùi ch∆°i...';
                } else if (gameState.vote_status && gameState.vote_status.votes_needed > 0) {
                    statusDiv.textContent = `C·∫ßn ${gameState.vote_status.votes_needed} vote n·ªØa ƒë·ªÉ b·∫Øt ƒë·∫ßu game`;
                } else {
                    statusDiv.textContent = 'ƒê·ªß vote! Game s·∫Ω b·∫Øt ƒë·∫ßu...';
                }
            } else if (gameState.game_running) {
                statusDiv.textContent = 'Game ƒëang ch·∫°y!';
                statusDiv.style.color = '#2ecc71';
            } else {
                const aliveSnakes = gameState.snakes.filter(s => s.alive);
                if (aliveSnakes.length === 1) {
                    const winner = aliveSnakes[0];
                    if (winner.player_id === myPlayerId) {
                        statusDiv.textContent = 'Ch√∫c m·ª´ng! B·∫°n th·∫Øng! üéâ';
                        statusDiv.style.color = '#2ecc71';
                    } else {
                        statusDiv.textContent = `Game k·∫øt th√∫c! Ng∆∞·ªùi th·∫Øng: ${winner.player_name}`;
                        statusDiv.style.color = '#e74c3c';
                    }
                } else {
                    statusDiv.textContent = 'Game k·∫øt th√∫c!';
                    statusDiv.style.color = '#e74c3c';
                }
            }
            
            // Update player list
            playersDiv.innerHTML = '';
            gameState.snakes.forEach((snake, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.style.color = colors[index % colors.length];
                const status = snake.alive ? 'üêç' : 'üíÄ';
                const isMe = snake.player_id === myPlayerId ? ' (B·∫°n)' : '';
                const displayName = snake.player_name || snake.player_id;
                const hasVoted = gameState.votes && gameState.votes[snake.player_id];
                const voteCheck = !gameState.game_started && hasVoted ? ' ‚úì' : '';
                const speedBoost = snake.has_speed_boost ? ' ‚ö°' : '';
                const speedReduction = snake.has_speed_reduction ? ' üêå' : '';
                playerDiv.textContent = `${status} ${displayName}${voteCheck}${isMe} - ${snake.score} ƒëi·ªÉm${speedBoost}${speedReduction}`;
                playersDiv.appendChild(playerDiv);
            });
            
            // Update leaderboard
            updateLeaderboard();
            
            // Draw game
            draw();
        }
        
        function updateLeaderboard() {
            if (!gameState) return;
            
            const leaderboardList = document.getElementById('leaderboardList');
            leaderboardList.innerHTML = '';
            
            // Sort snakes by total_score first, then by current score
            const sortedSnakes = [...gameState.snakes].sort((a, b) => {
                if (b.total_score !== a.total_score) {
                    return b.total_score - a.total_score;
                }
                return b.score - a.score;
            });
            
            sortedSnakes.forEach((snake, index) => {
                const rankDiv = document.createElement('div');
                const rankIcon = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                const isMe = snake.player_id === myPlayerId ? ' (B·∫°n)' : '';
                const displayName = snake.player_name || snake.player_id;
                const status = snake.alive ? '' : ' üíÄ';
                rankDiv.style.color = colors[gameState.snakes.findIndex(s => s.player_id === snake.player_id) % colors.length];
                
                // Show both current score and total score
                const currentScore = snake.score > 0 ? ` (${snake.score})` : '';
                rankDiv.textContent = `${rankIcon} ${displayName}${isMe} - ${snake.total_score}${currentScore}${status}`;
                leaderboardList.appendChild(rankDiv);
            });
        }
        
        function addChatMessage(playerName, message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message chat-player';
            messageDiv.innerHTML = `<strong>${playerName}:</strong> ${message}`;
            chatMessages.appendChild(messageDiv);
            
            // Limit to 10 messages
            while (chatMessages.children.length > 10) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
            
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function addSystemMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message chat-system';
            messageDiv.textContent = message;
            chatMessages.appendChild(messageDiv);
            
            // Limit to 10 messages
            while (chatMessages.children.length > 10) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
            
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function draw() {
            if (!gameState) return;
            
            // Clear canvas
            ctx.fillStyle = '#0f1419';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 0.5;
            for (let x = 0; x <= canvas.width; x += 20) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += 20) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw food
            gameState.food.forEach(food => {
                let color = '#e74c3c'; // Default red for normal food
                if (food.type === 'white') {
                    color = '#ffffff'; // White food
                } else if (food.type === 'purple') {
                    color = '#9b59b6'; // Purple food
                } else if (food.type === 'black') {
                    color = '#34495e'; // Dark blue-gray food
                } else if (food.type === 'gray') {
                    color = '#95a5a6'; // Gray food
                } else if (food.type === 'gold') {
                    color = '#FFD700'; // Gold food
                } else if (food.type === 'yellow') {
                    color = '#FFFF00'; // Yellow food
                }
                
                ctx.fillStyle = color;
                ctx.fillRect(food.x, food.y, 20, 20);
                // Add glow effect
                ctx.shadowBlur = 10;
                ctx.shadowColor = color;
                ctx.fillRect(food.x + 2, food.y + 2, 16, 16);
                ctx.shadowBlur = 0;
            });
            
            // Draw deadly gold food (if present)
            if (gameState.deadly_gold_food) {
                gameState.deadly_gold_food.forEach(deadlyFood => {
                    ctx.fillStyle = '#FF8C00'; // Dark orange for deadly gold
                    ctx.fillRect(deadlyFood.x, deadlyFood.y, 20, 20);
                    // Add danger glow effect
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#FF4500'; // Red-orange glow
                    ctx.fillRect(deadlyFood.x + 2, deadlyFood.y + 2, 16, 16);
                    ctx.shadowBlur = 0;
                    
                    // Add skull symbol for deadly food
                    ctx.fillStyle = '#000000';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üíÄ', deadlyFood.x + 10, deadlyFood.y + 15);
                });
            }
            
            // Draw snakes
            gameState.snakes.forEach((snake, index) => {
                if (snake.body.length === 0) return;
                
                const color = colors[index % colors.length];
                const isAlive = snake.alive;
                const isMe = snake.player_id === myPlayerId;
                const hasSpeedBoost = snake.has_speed_boost;
                const hasSpeedReduction = snake.has_speed_reduction;
                
                snake.body.forEach((segment, segIndex) => {
                    if (segIndex === 0) {
                        // Snake head
                        ctx.fillStyle = isAlive ? color : '#7f8c8d';
                        ctx.fillRect(segment[0], segment[1], 20, 20);
                        
                        // Head border (golden for own snake, white for speed boost, red for speed reduction)
                        if (isMe) {
                            ctx.strokeStyle = '#f1c40f';
                            ctx.lineWidth = 3;
                        } else if (hasSpeedBoost) {
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 3;
                        } else if (hasSpeedReduction) {
                            ctx.strokeStyle = '#e74c3c';
                            ctx.lineWidth = 3;
                        } else {
                            ctx.strokeStyle = '#2c3e50';
                            ctx.lineWidth = 2;
                        }
                        ctx.strokeRect(segment[0], segment[1], 20, 20);
                        
                        // Speed boost glow effect
                        if (hasSpeedBoost && isAlive) {
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = '#ffffff';
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(segment[0] - 2, segment[1] - 2, 24, 24);
                            ctx.shadowBlur = 0;
                        }
                        
                        // Speed reduction effect (dark red glow)
                        if (hasSpeedReduction && isAlive) {
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = '#e74c3c';
                            ctx.strokeStyle = '#e74c3c';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(segment[0] - 1, segment[1] - 1, 22, 22);
                            ctx.shadowBlur = 0;
                        }
                        
                        // Eyes
                        if (isAlive) {
                            ctx.fillStyle = '#2c3e50';
                            ctx.fillRect(segment[0] + 5, segment[1] + 5, 3, 3);
                            ctx.fillRect(segment[0] + 12, segment[1] + 5, 3, 3);
                        }
                    } else {
                        // Snake body
                        const alpha = isAlive ? Math.max(0.3, 1 - segIndex * 0.1) : 0.3;
                        ctx.fillStyle = isAlive ? color + Math.round(alpha * 255).toString(16).padStart(2, '0') : '#7f8c8d80';
                        ctx.fillRect(segment[0], segment[1], 20, 20);
                        
                        // Speed boost glow on body
                        if (hasSpeedBoost && isAlive && segIndex < 3) {
                            ctx.shadowBlur = 5;
                            ctx.shadowColor = '#ffffff';
                            ctx.fillRect(segment[0], segment[1], 20, 20);
                            ctx.shadowBlur = 0;
                        }
                        
                        ctx.strokeStyle = '#2c3e50';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(segment[0], segment[1], 20, 20);
                    }
                });
            });
        }
        
        function updateVoteUI(voteStatus, votes) {
            voteCount.textContent = voteStatus.voted_count;
            totalPlayers.textContent = voteStatus.total_players;
            votesNeeded.textContent = voteStatus.votes_needed;
            
            // Update vote button
            const hasVoted = votes && votes[myPlayerId];
            voteButton.disabled = hasVoted;
            voteButton.textContent = hasVoted ? 'ƒê√£ vote ‚úì' : 'Vote ƒë·ªÉ b·∫Øt ƒë·∫ßu';
        }
        
        // Event handlers
        voteButton.addEventListener('click', function() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    type: 'vote_start'
                }));
            }
        });
        
        startButton.addEventListener('click', function() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    type: 'start_game'
                }));
            }
        });
        
        restartButton.addEventListener('click', function() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    type: 'restart_game'
                }));
            }
        });
        
        // Name input handlers
        joinButton.addEventListener('click', function() {
            const name = nameInput.value.trim();
            console.log('Join button clicked, name:', name);
            if (name.length > 0) {
                myPlayerName = name;
                console.log('Player name set to:', myPlayerName);
                nameModal.style.display = 'none';
                connectWebSocket();
            } else {
                console.log('Name is empty, cannot join');
                alert('Vui l√≤ng nh·∫≠p t√™n!');
            }
        });
        
        nameInput.addEventListener('keypress', function(event) {
            console.log('Key pressed:', event.key);
            if (event.key === 'Enter') {
                console.log('Enter key pressed, triggering join');
                joinButton.click();
            }
        });
        
        // Chat handlers
        chatInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                const message = chatInput.value.trim();
                if (message.length > 0 && socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({
                        type: 'chat',
                        message: message
                    }));
                    chatInput.value = '';
                }
            }
        });
        
        // Keyboard controls
        document.addEventListener('keydown', function(event) {
            if (!socket || socket.readyState !== WebSocket.OPEN || !gameState || !gameState.game_running) {
                return;
            }
            
            // Get current player's snake
            const mySnake = gameState.snakes.find(s => s.player_id === myPlayerId);
            if (!mySnake || !mySnake.alive) {
                return;
            }
            
            let direction = null;
            
            switch(event.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    direction = 'up';
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    direction = 'down';
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    direction = 'left';
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    direction = 'right';
                    break;
            }
            
            if (direction) {
                // Prevent reverse direction on client side
                const opposite = {
                    'up': 'down',
                    'down': 'up',
                    'left': 'right',
                    'right': 'left'
                };
                
                // Additional check: if snake has more than 1 segment, 
                // don't allow direction that would immediately hit the second segment
                let canChangeDirection = true;
                if (mySnake.body.length > 1) {
                    const head = mySnake.body[0];
                    const second = mySnake.body[1];
                    
                    // Calculate where the head would be after the move
                    let newHead = null;
                    if (direction === 'up') {
                        newHead = [head[0], head[1] - 20];
                    } else if (direction === 'down') {
                        newHead = [head[0], head[1] + 20];
                    } else if (direction === 'left') {
                        newHead = [head[0] - 20, head[1]];
                    } else if (direction === 'right') {
                        newHead = [head[0] + 20, head[1]];
                    }
                    
                    // Don't allow if new head would be on second segment
                    if (newHead && newHead[0] === second[0] && newHead[1] === second[1]) {
                        canChangeDirection = false;
                    }
                }
                
                // Only send if direction is valid
                if (direction !== opposite[mySnake.direction] && canChangeDirection) {
                    event.preventDefault();
                    socket.send(JSON.stringify({
                        type: 'move',
                        direction: direction
                    }));
                }
            }
        });
        
        // Focus name input when page loads
        nameInput.focus();
    </script>
</body>
</html>

phantomal@raspberrypi:~/snake $ ls
http_server.py  index.html  requirements.txt  venv
phantomal@raspberrypi:~/snake $ cat requirements.txt 
websockets==11.0.3
asyncio
phantomal@raspberrypi:~/snake $ ^C
phantomal@raspberrypi:~/snake $ 
phantomal@raspberrypi:~/snake $ ls
http_server.py  index.html  requirements.txt  venv
phantomal@raspberrypi:~/snake $ cat http_server.py 
#!/usr/bin/env python3
import os
import http.server
import socketserver
import socket
import threading
import json
import random
import time
import signal
from typing import Dict, List
import hashlib
import base64
import struct

# HTTP server configuration
HTTP_PORT = 666

# Game constants
BOARD_WIDTH = 1000
BOARD_HEIGHT = 700
GRID_SIZE = 20
FOOD_COUNT_PER_PLAYER = 1


class Snake:
    def __init__(self, player_id: str, player_name: str, x: int, y: int):
        self.player_id = player_id
        self.player_name = player_name
        self.body = [(x, y)]
        self.direction = 'right'
        self.alive = True
        self.score = 0
        self.total_score = 0  # Total accumulated score across all games
        self.speed_boost_end = 0  # Timestamp when speed boost ends
        self.speed_reduction_end = 0  # Timestamp when speed reduction ends

    def move(self):
        if not self.alive:
            return

        head_x, head_y = self.body[0]

        if self.direction == 'up':
            new_head = (head_x, head_y - GRID_SIZE)
        elif self.direction == 'down':
            new_head = (head_x, head_y + GRID_SIZE)
        elif self.direction == 'left':
            new_head = (head_x - GRID_SIZE, head_y)
        elif self.direction == 'right':
            new_head = (head_x + GRID_SIZE, head_y)

        # Check wall collision
        if (new_head[0] < 0 or new_head[0] >= BOARD_WIDTH or
                new_head[1] < 0 or new_head[1] >= BOARD_HEIGHT):
            self.alive = False
            return

        self.body.insert(0, new_head)

    def grow(self):
        pass

    def grow_multiple(self, count):
        """Grow the snake by multiple segments"""
        for _ in range(count):
            if len(self.body) > 0:
                # Add segment at the tail position
                tail = self.body[-1]
                self.body.append(tail)

    def apply_speed_boost(self, duration_seconds=5):
        """Apply speed boost for specified duration"""
        self.speed_boost_end = time.time() + duration_seconds

    def apply_double_speed_boost(self, duration_seconds=5):
        """Apply double speed boost for specified duration"""
        self.speed_boost_end = time.time() + duration_seconds * 2

    def apply_speed_reduction(self, duration_seconds=5):
        """Apply 80% speed reduction for specified duration"""
        self.speed_reduction_end = time.time() + duration_seconds

    def reduce_length_by_half(self):
        """Reduce snake length by half (minimum 1 segment)"""
        if len(self.body) > 1:
            new_length = max(1, len(self.body) // 2)
            self.body = self.body[:new_length]

    def has_speed_boost(self):
        """Check if snake currently has speed boost"""
        return time.time() < self.speed_boost_end

    def has_speed_reduction(self):
        """Check if snake currently has speed reduction"""
        return time.time() < self.speed_reduction_end

    def shrink(self):
        if len(self.body) > 1:
            self.body.pop()

    def check_self_collision(self):
        head = self.body[0]
        return head in self.body[1:]

    def to_dict(self):
        return {
            'player_id': self.player_id,
            'player_name': self.player_name,
            'body': self.body,
            'alive': self.alive,
            'score': self.score,
            'total_score': self.total_score,
            'has_speed_boost': self.has_speed_boost(),
            'has_speed_reduction': self.has_speed_reduction()
        }


class GameState:
    def __init__(self):
        self.players: Dict[str, object] = {}
        self.snakes: Dict[str, Snake] = {}
        # Changed to list of dicts to include food type
        self.food: List[dict] = []
        # Deadly gold food with expiry time
        self.deadly_gold_food: List[dict] = []
        self.game_started = False
        self.game_running = False
        self.votes: Dict[str, bool] = {}  # Track player votes to start game
        self._lock = threading.Lock()  # Thread safety

    def add_player(self, websocket, player_id: str, player_name: str = ''):
        with self._lock:
            # Check if game is already running
            if self.game_running:
                return False  # Cannot join during active game

            self.players[player_id] = websocket
            x = random.randint(5, (BOARD_WIDTH // GRID_SIZE) - 5) * GRID_SIZE
            y = random.randint(5, (BOARD_HEIGHT // GRID_SIZE) - 5) * GRID_SIZE
            display_name = player_name or f"Player{len(self.snakes) + 1}"
            self.snakes[player_id] = Snake(player_id, display_name, x, y)
            self.votes[player_id] = False  # Initialize vote as False
            self.update_food_unsafe()
            return True

    def remove_player(self, player_id: str):
        with self._lock:
            if player_id in self.players:
                del self.players[player_id]
            if player_id in self.snakes:
                del self.snakes[player_id]
            if player_id in self.votes:
                del self.votes[player_id]
            self.update_food_unsafe()

    def vote_to_start(self, player_id: str):
        """Player votes to start the game"""
        with self._lock:
            if player_id in self.votes and not self.game_started:
                self.votes[player_id] = True
                return self.check_votes_ready()
            return False

    def check_votes_ready(self):
        """Check if all players have voted to start"""
        if len(self.players) < 1:
            return False
        # All players must vote to start
        return (all(self.votes.values()) and
                len(self.votes) == len(self.players))

    def get_vote_status(self):
        """Get current voting status"""
        total_players = len(self.players)
        voted_count = sum(1 for vote in self.votes.values() if vote)
        return {
            'total_players': total_players,
            'voted_count': voted_count,
            'votes_needed': total_players - voted_count
        }

    def update_food_unsafe(self):
        """Update food without locking - call only when already locked"""
        target_food_count = len(self.players) * FOOD_COUNT_PER_PLAYER
        while len(self.food) < target_food_count:
            x = random.randint(0, (BOARD_WIDTH // GRID_SIZE) - 1) * GRID_SIZE
            y = random.randint(0, (BOARD_HEIGHT // GRID_SIZE) - 1) * GRID_SIZE
            valid_position = True
            for snake in self.snakes.values():
                if (x, y) in snake.body:
                    valid_position = False
                    break

            # Check if position is already occupied by existing food
            position_occupied = False
            for food_item in self.food:
                if food_item['x'] == x and food_item['y'] == y:
                    position_occupied = True
                    break

            if valid_position and not position_occupied:
                # Determine food type: 16% normal, 16% white, 16% purple, 8% black, 16% gray, 8% gold, 20% yellow
                rand = random.random()
                if rand < 0.16:
                    food_type = 'normal'
                elif rand < 0.32:
                    food_type = 'white'  # +10 length
                elif rand < 0.48:
                    food_type = 'purple'  # speed boost 5s
                elif rand < 0.56:
                    food_type = 'black'  # +20 length
                elif rand < 0.72:
                    food_type = 'gray'  # reduce speed by 80% for 5s
                elif rand < 0.8:
                    food_type = 'gold'  # special gold food
                else:
                    food_type = 'yellow'  # spawn 50 random foods

                self.food.append({
                    'x': x,
                    'y': y,
                    'type': food_type
                })

    def create_multiple_food(self, count):
        """Create multiple random foods (excluding yellow food)"""
        for _ in range(count):
            attempts = 0
            while attempts < 50:  # Limit attempts to avoid infinite loop
                x = random.randint(
                    0, (BOARD_WIDTH // GRID_SIZE) - 1) * GRID_SIZE
                y = random.randint(
                    0, (BOARD_HEIGHT // GRID_SIZE) - 1) * GRID_SIZE

                # Check if position is valid (not on snakes or existing food)
                position_valid = True

                # Check snakes
                for snake in self.snakes.values():
                    if (x, y) in snake.body:
                        position_valid = False
                        break

                # Check existing food
                if position_valid:
                    for food_item in self.food:
                        if food_item['x'] == x and food_item['y'] == y:
                            position_valid = False
                            break

                # Check existing deadly gold food
                if position_valid:
                    for gold_food in self.deadly_gold_food:
                        if gold_food['x'] == x and gold_food['y'] == y:
                            position_valid = False
                            break

                if position_valid:
                    # Choose random food type (excluding yellow)
                    rand = random.random()
                    if rand < 0.25:
                        food_type = 'normal'
                    elif rand < 0.5:
                        food_type = 'white'
                    elif rand < 0.7:
                        food_type = 'purple'
                    elif rand < 0.8:
                        food_type = 'black'
                    elif rand < 0.95:
                        food_type = 'gray'
                    else:
                        food_type = 'gold'

                    self.food.append({
                        'x': x,
                        'y': y,
                        'type': food_type
                    })
                    break

                attempts += 1

    def create_deadly_gold_food(self, count):
        """Create deadly gold food that expires in 5 seconds"""
        current_time = time.time()
        for _ in range(count):
            attempts = 0
            while attempts < 50:  # Limit attempts to avoid infinite loop
                x = random.randint(
                    0, (BOARD_WIDTH // GRID_SIZE) - 1) * GRID_SIZE
                y = random.randint(
                    0, (BOARD_HEIGHT // GRID_SIZE) - 1) * GRID_SIZE

                # Check if position is valid (not on snakes or existing food)
                position_valid = True

                # Check snakes
                for snake in self.snakes.values():
                    if (x, y) in snake.body:
                        position_valid = False
                        break

                # Check existing food
                if position_valid:
                    for food_item in self.food:
                        if food_item['x'] == x and food_item['y'] == y:
                            position_valid = False
                            break

                # Check existing deadly gold food
                if position_valid:
                    for gold_food in self.deadly_gold_food:
                        if gold_food['x'] == x and gold_food['y'] == y:
                            position_valid = False
                            break

                if position_valid:
                    self.deadly_gold_food.append({
                        'x': x,
                        'y': y,
                        'type': 'deadly_gold',
                        'expires_at': current_time + 5  # Expires in 5 seconds
                    })
                    break

                attempts += 1

    def clean_expired_deadly_gold_food(self):
        """Remove expired deadly gold food"""
        current_time = time.time()
        self.deadly_gold_food = [
            food for food in self.deadly_gold_food
            if food['expires_at'] > current_time
        ]

    def update_food(self):
        with self._lock:
            self.update_food_unsafe()

    def start_game(self):
        with self._lock:
            if self.check_votes_ready() and not self.game_started:
                self.game_started = True
                self.game_running = True
                # Reset votes for next round
                for player_id in self.votes:
                    self.votes[player_id] = False
                return True
            return False

    def restart_game(self):
        with self._lock:
            self.game_started = False
            self.game_running = False
            # Reset all votes
            for player_id in self.votes:
                self.votes[player_id] = False
            for player_id, snake in self.snakes.items():
                # Save current score to total_score before reset
                snake.total_score += snake.score

                x = random.randint(
                    5, (BOARD_WIDTH // GRID_SIZE) - 5) * GRID_SIZE
                y = random.randint(
                    5, (BOARD_HEIGHT // GRID_SIZE) - 5) * GRID_SIZE
                snake.body = [(x, y)]
                snake.direction = 'right'
                snake.alive = True
                snake.score = 0
            self.food = []
            self.update_food_unsafe()

    def update_game(self):
        with self._lock:
            if not self.game_running:
                return

            for snake in self.snakes.values():
                snake.move()

            alive_snakes = [
                snake for snake in self.snakes.values() if snake.alive]

            # Head-to-head collisions
            head_collisions = []
            for i, snake1 in enumerate(alive_snakes):
                for j, snake2 in enumerate(alive_snakes[i+1:], i+1):
                    if snake1.body[0] == snake2.body[0]:
                        head_collisions.append((snake1, snake2))

            for snake1, snake2 in head_collisions:
                len1, len2 = len(snake1.body), len(snake2.body)
                if len1 > len2:
                    snake2.alive = False
                    snake1.score += 20
                elif len2 > len1:
                    snake1.alive = False
                    snake2.score += 20
                else:
                    snake1.alive = False
                    snake2.alive = False

            for snake in self.snakes.values():
                if not snake.alive:
                    continue
                head = snake.body[0]
                if snake.check_self_collision():
                    snake.alive = False
                    continue
                for other_snake in self.snakes.values():
                    if (other_snake.player_id != snake.player_id and
                            other_snake.alive and head in other_snake.body[1:]):
                        snake.alive = False
                        other_snake.score += 10
                        break

                # Check food collision
                eaten_food = None
                for food_item in self.food:
                    if head[0] == food_item['x'] and head[1] == food_item['y']:
                        eaten_food = food_item
                        break

                # Check deadly gold food collision
                # Use slice to avoid modification during iteration
                for gold_food in self.deadly_gold_food[:]:
                    if head[0] == gold_food['x'] and head[1] == gold_food['y']:
                        # Snake dies from eating deadly gold food
                        snake.alive = False
                        self.deadly_gold_food.remove(gold_food)
                        break

                if eaten_food:
                    self.food.remove(eaten_food)
                    if eaten_food['type'] == 'normal':
                        snake.grow()
                        snake.score += 10
                    elif eaten_food['type'] == 'white':
                        snake.grow_multiple(10)
                        snake.score += 50  # Bonus points for special food
                    elif eaten_food['type'] == 'purple':
                        snake.apply_speed_boost(5)
                        snake.score += 30  # Bonus points for special food
                    elif eaten_food['type'] == 'black':
                        snake.grow_multiple(20)
                        snake.score += 100  # Higher bonus for +20 length
                    elif eaten_food['type'] == 'gray':
                        snake.apply_speed_reduction(5)
                        snake.score -= 10  # Small penalty for speed reduction
                    elif eaten_food['type'] == 'gold':
                        # Gold food: creates deadly gold food pieces
                        player_count = len(
                            [s for s in self.snakes.values() if s.alive])
                        deadly_count = player_count * 20
                        self.create_deadly_gold_food(deadly_count)
                        snake.score += 200  # Big bonus for risky gold food
                    elif eaten_food['type'] == 'yellow':
                        # Yellow food: spawn 50 random foods (excluding yellow)
                        print(f"DEBUG: Yellow food eaten! Creating 50 foods...")
                        self.create_multiple_food(50)
                        snake.score += 150  # Good bonus for yellow food
                        print(
                            f"DEBUG: Total food count after yellow: {len(self.food)}")
                    self.update_food_unsafe()
                else:
                    snake.shrink()

            alive_count = sum(
                1 for snake in self.snakes.values() if snake.alive)
            if alive_count <= 1 and len(self.snakes) > 1:
                self.game_running = False

    def to_dict(self):
        with self._lock:
            vote_status = self.get_vote_status()
            return {
                'snakes': [snake.to_dict() for snake in self.snakes.values()],
                'food': self.food.copy(),
                'deadly_gold_food': self.deadly_gold_food.copy(),
                'game_started': self.game_started,
                'game_running': self.game_running,
                'player_count': len(self.players),
                'vote_status': vote_status,
                'votes': self.votes.copy()
            }


# Global game state
game_state = GameState()

# Global server reference for shutdown
httpd_server = None
game_thread = None


def signal_handler(sig, frame):
    """Handle Ctrl+C gracefully"""
    print("\nüõë Shutting down server...")

    # Close all WebSocket connections
    for player_id, websocket in list(game_state.players.items()):
        try:
            # Send close frame to client
            websocket.send_close_frame()
        except Exception:
            pass

    # Clear all connections
    game_state.players.clear()
    game_state.snakes.clear()

    print("‚úÖ Server stopped cleanly")
    # Force exit without waiting for server shutdown
    os._exit(0)


class WebSocketHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, directory=os.path.dirname(os.path.abspath(__file__)), **kwargs)

    def end_headers(self):
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        # Add CSP header to allow inline scripts and styles
        self.send_header('Content-Security-Policy',
                         "default-src 'self'; "
                         "script-src 'self' 'unsafe-inline'; "
                         "style-src 'self' 'unsafe-inline'; "
                         "connect-src 'self' ws: wss:; "
                         "img-src 'self' data:;")
        super().end_headers()

    def do_GET(self):
        # Check if this is a WebSocket upgrade request
        if (self.headers.get('Upgrade', '').lower() == 'websocket' and
                self.headers.get('Connection', '').lower() == 'upgrade'):
            self.handle_websocket_upgrade()
        else:
            # Regular HTTP request
            super().do_GET()

    def handle_websocket_upgrade(self):
        try:
            # Get WebSocket key
            key = self.headers.get('Sec-WebSocket-Key')
            if not key:
                self.send_error(400, "Missing Sec-WebSocket-Key")
                return

            # Generate accept key
            magic = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'
            accept = base64.b64encode(
                hashlib.sha1((key + magic).encode()).digest()
            ).decode()

            # Send WebSocket handshake response
            self.send_response(101, 'Switching Protocols')
            self.send_header('Upgrade', 'websocket')
            self.send_header('Connection', 'Upgrade')
            self.send_header('Sec-WebSocket-Accept', accept)
            self.end_headers()

            # Handle WebSocket connection
            self.handle_websocket_connection()

        except Exception as e:
            print(f"WebSocket handshake error: {e}")
            self.send_error(500, "WebSocket handshake failed")

    def handle_websocket_connection(self):
        player_id = f"player_{int(time.time() * 1000)}_{random.randint(1000, 9999)}"
        player_name = ''
        print(f"DEBUG: New WebSocket connection, player_id: {player_id}")

        try:
            while True:
                try:
                    # Read WebSocket frame
                    message = self.read_websocket_frame()
                    if message is None:
                        break

                    data = json.loads(message)

                    if data['type'] == 'join':
                        player_name = data.get('name', 'Anonymous')
                        print(
                            f"DEBUG: Player joining with name: '{player_name}'")

                        # Try to add player
                        if game_state.add_player(self, player_id, player_name):
                            # Successfully joined
                            response = {
                                'type': 'init',
                                'player_id': player_id,
                                'game_state': game_state.to_dict()
                            }
                            print(
                                f"DEBUG: Sending init response to {player_name}")
                            self.send_websocket_message(json.dumps(response))
                            self.broadcast_game_state()
                            self.broadcast_system_message(
                                f"{player_name} ƒë√£ tham gia game!")
                        else:
                            # Cannot join - game is running
                            response = {
                                'type': 'join_rejected',
                                'reason': 'Game ƒëang ch·∫°y, kh√¥ng th·ªÉ tham gia!'
                            }
                            self.send_websocket_message(json.dumps(response))
                            print(
                                f"DEBUG: Rejected {player_name} - game running")
                            break

                    elif data['type'] == 'start_game':
                        if game_state.start_game():
                            self.broadcast_game_state()
                            self.broadcast_system_message("Game ƒë√£ b·∫Øt ƒë·∫ßu!")
                        else:
                            # Not enough votes, send vote status
                            vote_status = game_state.get_vote_status()
                            self.send_websocket_message(json.dumps({
                                'type': 'vote_needed',
                                'vote_status': vote_status
                            }))

                    elif data['type'] == 'vote_start':
                        if game_state.vote_to_start(player_id):
                            # All votes collected, start game automatically
                            game_state.start_game()
                            self.broadcast_game_state()
                            self.broadcast_system_message(
                                "T·∫•t c·∫£ ƒë√£ vote! Game b·∫Øt ƒë·∫ßu!")
                        else:
                            # Update vote status
                            self.broadcast_vote_status()
                            if player_id in game_state.snakes:
                                player_name = game_state.snakes[player_id].player_name
                                vote_status = game_state.get_vote_status()
                                self.broadcast_system_message(
                                    f"{player_name} ƒë√£ vote ƒë·ªÉ b·∫Øt ƒë·∫ßu! "
                                    f"({vote_status['voted_count']}/{vote_status['total_players']})")

                    elif data['type'] == 'restart_game':
                        game_state.restart_game()
                        self.broadcast_game_state()
                        self.broadcast_system_message(
                            "Game ƒë√£ ƒë∆∞·ª£c reset! H√£y vote ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i.")

                    elif data['type'] == 'chat':
                        message_text = data.get('message', '').strip()
                        if message_text and player_id in game_state.snakes:
                            snake = game_state.snakes[player_id]
                            self.broadcast_chat_message(
                                snake.player_name, message_text)

                    elif data['type'] == 'move' and player_id in game_state.snakes:
                        snake = game_state.snakes[player_id]
                        if snake.alive and game_state.game_running and len(snake.body) > 0:
                            direction = data['direction']
                            opposite = {
                                'up': 'down', 'down': 'up',
                                'left': 'right', 'right': 'left'
                            }

                            can_change_direction = True
                            if len(snake.body) > 1:
                                head_x, head_y = snake.body[0]
                                second_x, second_y = snake.body[1]
                                new_head = None
                                if direction == 'up':
                                    new_head = (head_x, head_y - GRID_SIZE)
                                elif direction == 'down':
                                    new_head = (head_x, head_y + GRID_SIZE)
                                elif direction == 'left':
                                    new_head = (head_x - GRID_SIZE, head_y)
                                elif direction == 'right':
                                    new_head = (head_x + GRID_SIZE, head_y)
                                if new_head == (second_x, second_y):
                                    can_change_direction = False

                            if (direction != opposite.get(snake.direction) and can_change_direction):
                                snake.direction = direction

                except json.JSONDecodeError:
                    continue
                except Exception as e:
                    print(f"WebSocket message error: {e}")
                    break

        except Exception as e:
            print(f"WebSocket connection error: {e}")
        finally:
            game_state.remove_player(player_id)
            self.broadcast_game_state()

    def read_websocket_frame(self):
        try:
            # Read first 2 bytes
            data = self.rfile.read(2)
            if len(data) != 2:
                return None

            fin = (data[0] & 0x80) >> 7
            opcode = data[0] & 0x0f
            masked = (data[1] & 0x80) >> 7
            payload_len = data[1] & 0x7f

            # Handle extended payload length
            if payload_len == 126:
                data = self.rfile.read(2)
                if len(data) != 2:
                    return None
                payload_len = struct.unpack('>H', data)[0]
            elif payload_len == 127:
                data = self.rfile.read(8)
                if len(data) != 8:
                    return None
                payload_len = struct.unpack('>Q', data)[0]

            # Read mask key
            if masked:
                mask = self.rfile.read(4)
                if len(mask) != 4:
                    return None

            # Read payload
            payload = self.rfile.read(payload_len)
            if len(payload) != payload_len:
                return None

            # Unmask payload
            if masked:
                payload = bytes(payload[i] ^ mask[i % 4]
                                for i in range(len(payload)))

            # Handle close frame
            if opcode == 0x8:
                print("DEBUG: WebSocket close frame received")
                return None

            # Only process text frames
            if opcode != 0x1:
                return None

            return payload.decode('utf-8')

        except UnicodeDecodeError as e:
            print(f"Unicode decode error: {e}")
            return None
        except Exception as e:
            print(f"Read frame error: {e}")
            return None

    def send_websocket_message(self, message):
        try:
            message_bytes = message.encode('utf-8')
            length = len(message_bytes)

            # Create frame
            frame = bytearray()
            frame.append(0x81)  # FIN=1, opcode=text

            if length <= 125:
                frame.append(length)
            elif length <= 65535:
                frame.append(126)
                frame.extend(struct.pack('>H', length))
            else:
                frame.append(127)
                frame.extend(struct.pack('>Q', length))

            frame.extend(message_bytes)
            self.wfile.write(frame)
            self.wfile.flush()

        except Exception as e:
            print(f"Send message error: {e}")

    def send_close_frame(self):
        """Send WebSocket close frame"""
        try:
            # Close frame: FIN=1, opcode=8, no payload
            frame = bytearray([0x88, 0x00])
            self.wfile.write(frame)
            self.wfile.flush()
        except:
            pass

    def broadcast_game_state(self):
        message = json.dumps({
            'type': 'game_state',
            'game_state': game_state.to_dict()
        })
        for player_id, websocket in list(game_state.players.items()):
            try:
                websocket.send_websocket_message(message)
            except:
                game_state.remove_player(player_id)

    def broadcast_chat_message(self, player_name: str, message_text: str):
        message = json.dumps({
            'type': 'chat',
            'player_name': player_name,
            'message': message_text
        })
        for player_id, websocket in list(game_state.players.items()):
            try:
                websocket.send_websocket_message(message)
            except:
                game_state.remove_player(player_id)

    def broadcast_system_message(self, message_text: str):
        message = json.dumps({
            'type': 'system',
            'message': message_text
        })
        for player_id, websocket in list(game_state.players.items()):
            try:
                websocket.send_websocket_message(message)
            except:
                game_state.remove_player(player_id)

    def broadcast_vote_status(self):
        """Broadcast current voting status to all players"""
        vote_status = game_state.get_vote_status()
        message = json.dumps({
            'type': 'vote_status',
            'vote_status': vote_status,
            'votes': game_state.votes.copy()
        })
        for player_id, websocket in list(game_state.players.items()):
            try:
                websocket.send_websocket_message(message)
            except:
                game_state.remove_player(player_id)


def get_local_ip():
    """Get the local IP address of this machine"""
    try:
        # Connect to a dummy address to get local IP
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
            s.connect(("8.8.8.8", 80))
            local_ip = s.getsockname()[0]
        return local_ip
    except Exception:
        return "localhost"


def start_combined_server():
    """Start combined HTTP and WebSocket server"""
    global httpd_server, game_thread

    # Set up signal handler for graceful shutdown
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # Enable SO_REUSEADDR to prevent "Address already in use" error
    socketserver.TCPServer.allow_reuse_address = True

    # Use ThreadingTCPServer to handle multiple connections simultaneously
    with socketserver.ThreadingTCPServer(("", HTTP_PORT), WebSocketHTTPRequestHandler) as httpd:
        httpd_server = httpd
        local_ip = get_local_ip()
        print("üêç SNAKE GAME - COMBINED SERVER (THREADED)")
        print("=" * 50)
        print(f"üñ•Ô∏è  Server IP: {local_ip}")
        print(f"üéÆ Game URL: http://{local_ip}:{HTTP_PORT}/index.html")
        print(f"üîå WebSocket: ws://{local_ip}:{HTTP_PORT}")
        print("=" * 50)
        print("üìã SHARE WITH OTHERS:")
        print(f"   http://{local_ip}:{HTTP_PORT}/index.html")
        print("=" * 50)
        print("‚ö° Server started! Multiple connections supported!")
        print("üí° Press Ctrl+C to stop")

        # Start game loop in a separate thread
        game_thread = threading.Thread(target=game_loop, daemon=True)
        game_thread.start()

        try:
            httpd.serve_forever()
        except KeyboardInterrupt:
            print("\nüõë Shutting down server...")

            # Close all WebSocket connections
            for player_id, websocket in list(game_state.players.items()):
                try:
                    websocket.send_close_frame()
                except Exception:
                    pass

            # Clear all connections
            game_state.players.clear()
            game_state.snakes.clear()

            print("‚úÖ Server stopped cleanly")


def game_loop():
    """Game update loop"""
    tick_counter = 0
    while True:
        if game_state.game_running:
            tick_counter += 1

            # Clean expired deadly gold food
            with game_state._lock:
                game_state.clean_expired_deadly_gold_food()

            # Handle different speed updates
            with game_state._lock:
                for snake in game_state.snakes.values():
                    if not snake.alive:
                        continue

                    should_move = True

                    # Check if snake has speed reduction (80% slower, moves every 5 ticks)
                    if snake.has_speed_reduction() and tick_counter % 5 != 0:
                        should_move = False

                    if should_move:
                        snake.move()

                        # Check collisions
                        head = snake.body[0]
                        if snake.check_self_collision():
                            snake.alive = False
                            continue

                        for other_snake in game_state.snakes.values():
                            if (other_snake.player_id != snake.player_id and
                                    other_snake.alive and head in other_snake.body[1:]):
                                snake.alive = False
                                other_snake.score += 10
                                break

                        if not snake.alive:
                            continue

                        # Check food collision
                        eaten_food = None
                        for food_item in game_state.food:
                            if head[0] == food_item['x'] and head[1] == food_item['y']:
                                eaten_food = food_item
                                break

                        if eaten_food:
                            game_state.food.remove(eaten_food)
                            if eaten_food['type'] == 'normal':
                                snake.grow()
                                snake.score += 10
                            elif eaten_food['type'] == 'white':
                                snake.grow_multiple(10)
                                snake.score += 50
                            elif eaten_food['type'] == 'purple':
                                snake.apply_speed_boost(5)
                                snake.score += 30
                            elif eaten_food['type'] == 'black':
                                snake.grow_multiple(20)
                                snake.score += 100
                            elif eaten_food['type'] == 'gray':
                                snake.apply_speed_reduction(5)
                                snake.score -= 10
                            elif eaten_food['type'] == 'yellow':
                                # Yellow food: spawn 50 random foods (excluding yellow)
                                game_state.create_multiple_food(50)
                                snake.score += 150  # Good bonus for yellow food
                            game_state.update_food_unsafe()
                        else:
                            snake.shrink()

                    # Extra move for speed boosted snakes on even ticks
                    if snake.alive and snake.has_speed_boost() and tick_counter % 2 == 0:
                        snake.move()

                        # Check collisions for speed boost move
                        head = snake.body[0]
                        if snake.check_self_collision():
                            snake.alive = False
                            continue

                        for other_snake in game_state.snakes.values():
                            if (other_snake.player_id != snake.player_id and
                                    other_snake.alive and head in other_snake.body[1:]):
                                snake.alive = False
                                other_snake.score += 10
                                break

                        if not snake.alive:
                            continue

                        # Check food collision for speed boost move
                        eaten_food = None
                        for food_item in game_state.food:
                            if head[0] == food_item['x'] and head[1] == food_item['y']:
                                eaten_food = food_item
                                break

                        if eaten_food:
                            game_state.food.remove(eaten_food)
                            if eaten_food['type'] == 'normal':
                                snake.grow()
                                snake.score += 10
                            elif eaten_food['type'] == 'white':
                                snake.grow_multiple(10)
                                snake.score += 50
                            elif eaten_food['type'] == 'purple':
                                snake.apply_speed_boost(5)
                                snake.score += 30
                            elif eaten_food['type'] == 'black':
                                snake.grow_multiple(20)
                                snake.score += 100
                            elif eaten_food['type'] == 'gray':
                                snake.apply_speed_reduction(5)
                                snake.score -= 10
                            elif eaten_food['type'] == 'yellow':
                                # Yellow food: spawn 50 random foods (excluding yellow)
                                game_state.create_multiple_food(50)
                                snake.score += 150  # Good bonus for yellow food
                            game_state.update_food_unsafe()
                        else:
                            snake.shrink()

                # Check for game end
                alive_count = sum(
                    1 for snake in game_state.snakes.values() if snake.alive)
                if alive_count <= 1 and len(game_state.snakes) > 1:
                    # Save current scores to total_score when game ends
                    for snake in game_state.snakes.values():
                        snake.total_score += snake.score
                    game_state.game_running = False

            # Broadcast game state to all connected players
            message = json.dumps({
                'type': 'game_state',
                'game_state': game_state.to_dict()
            })
            for player_id, websocket in list(game_state.players.items()):
                try:
                    websocket.send_websocket_message(message)
                except:
                    game_state.remove_player(player_id)
        time.sleep(0.1)  # 100ms game tick


if __name__ == "__main__":
    start_combined_server()

phantomal@raspberrypi:~/snake $ cat index.html 
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Localhost</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2c3e50;
            color: white;
            margin: 0;
            padding: 20px;
            overflow: hidden; /* Disable scrollbar */
        }
        
        h1 {
            color: #ecf0f1;
            margin-bottom: 20px;
        }
        
        #gameContainer {
            position: relative;
            border: 3px solid #34495e;
            background-color: #1a252f;
            margin: 20px 0;
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        
        #gameCanvas {
            display: block;
            background-color: #0f1419;
        }
        
        #chatContainer {
            width: 300px;
            display: flex;
            flex-direction: column;
            background-color: #2c3e50;
            border-radius: 5px;
            padding: 10px;
        }
        
        #leftPanel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        #playerList {
            width: 280px;
            padding: 15px;
            background-color: #34495e;
            border-radius: 5px;
            min-height: 300px;
        }
        
        #leaderboard {
            width: 280px;
            padding: 15px;
            background-color: #2c3e50;
            border-radius: 5px;
            min-height: 200px;
        }
        
        #leaderboard h3 {
            margin-top: 0;
            color: #f39c12;
            font-size: 16px;
            border-bottom: 1px solid #34495e;
            padding-bottom: 10px;
        }
        
        #leaderboardList div {
            padding: 5px 0;
            border-bottom: 1px solid #34495e;
            font-size: 14px;
            word-wrap: break-word;
        }
        
        #leaderboardList div:last-child {
            border-bottom: none;
        }
        
        #voteControls {
            text-align: center;
        }
        
        #voteControls button {
            width: 100%;
            margin: 5px 0;
            padding: 8px 16px;
            font-size: 14px;
        }
        
        #playerList h3 {
            margin-top: 0;
            color: #ecf0f1;
            font-size: 16px;
            border-bottom: 1px solid #2c3e50;
            padding-bottom: 10px;
        }
        
        #players div {
            padding: 8px 0;
            border-bottom: 1px solid #2c3e50;
            font-size: 14px;
            word-wrap: break-word;
        }
        
        #players div:last-child {
            border-bottom: none;
        }
        
        #chatMessages {
            flex: 1;
            height: 400px;
            overflow-y: auto;
            background-color: #1a252f;
            border: 1px solid #34495e;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            color: white;
            font-size: 14px;
        }
        
        .chat-message {
            margin-bottom: 5px;
            word-wrap: break-word;
        }
        
        .chat-system {
            color: #f39c12;
            font-style: italic;
        }
        
        .chat-player {
            color: #3498db;
        }
        
        #chatInput {
            width: 100%;
            padding: 8px;
            border: 1px solid #34495e;
            border-radius: 3px;
            background-color: #1a252f;
            color: white;
            font-size: 14px;
        }
        
        #chatInput:focus {
            outline: none;
            border-color: #3498db;
        }
        
        #nameModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        #nameForm {
            background-color: #2c3e50;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #34495e;
        }
        
        #nameInput {
            width: 250px;
            padding: 12px;
            margin: 15px 0;
            border: 1px solid #34495e;
            border-radius: 5px;
            background-color: #1a252f;
            color: white;
            font-size: 16px;
            text-align: center;
        }
        
        #nameInput:focus {
            outline: none;
            border-color: #3498db;
        }
        
        #joinButton {
            padding: 12px 24px;
            font-size: 16px;
            background-color: #27ae60;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }
        
        #joinButton:hover {
            background-color: #219a52;
        }
        
        #joinButton:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
        }
        
        #controls {
            margin: 20px 0;
            text-align: center;
        }
        
        #foodLegend {
            background-color: #1a252f;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            border: 1px solid #34495e;
        }
        
        #foodLegend h4 {
            margin: 0 0 8px 0;
            color: #f39c12;
            font-size: 14px;
        }
        
        .food-type {
            margin: 3px 0;
            font-size: 12px;
            color: white;
        }
        
        button {
            padding: 12px 24px;
            font-size: 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
        }
        
        #gameInfo {
            display: flex;
            gap: 30px;
            margin: 10px 0;
            font-size: 18px;
        }
        
        #status {
            margin: 10px 0;
            font-size: 16px;
            color: #e74c3c;
        }
        
        #connectionStatus {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 10px 15px;
            border-radius: 5px;
            font-weight: bold;
        }
        
        .connected {
            background-color: #27ae60;
        }
        
        .disconnected {
            background-color: #e74c3c;
        }
    </style>
</head>
<body>
    <!-- Name Modal -->
    <div id="nameModal">
        <div id="nameForm">
            <h2>üêç Snake Game Multiplayer</h2>
            <p>Nh·∫≠p t√™n c·ªßa b·∫°n ƒë·ªÉ tham gia game:</p>
            <input type="text" id="nameInput" placeholder="T√™n c·ªßa b·∫°n" maxlength="20" />
            <br>
            <button id="joinButton">Tham gia Game</button>
        </div>
    </div>

    <h1>üêç Snake Game Multiplayer</h1>
    
    <div id="connectionStatus" class="disconnected">Ch·ªù k·∫øt n·ªëi...</div>
    
    <div id="status">Ch·ªù nh·∫≠p t√™n...</div>
    
    <div id="gameContainer">
        <div id="leftPanel">
            <div id="playerList">
                <h3>Danh s√°ch ng∆∞·ªùi ch∆°i:</h3>
                <div id="players"></div>
                <div id="voteControls" style="margin-top: 15px;">
                    <button id="voteButton" disabled>Vote ƒë·ªÉ b·∫Øt ƒë·∫ßu</button>
                    <button id="startButton" disabled style="display: none;">B·∫Øt ƒë·∫ßu Game</button>
                    <button id="restartButton" style="display: none;">Ch∆°i l·∫°i</button>
                </div>
                <div id="voteStatus" style="display: none; margin-top: 10px;">
                    <div>Votes: <span id="voteCount">0</span>/<span id="totalPlayers">0</span></div>
                    <div>C·∫ßn th√™m <span id="votesNeeded">0</span> vote ƒë·ªÉ b·∫Øt ƒë·∫ßu</div>
                </div>
            </div>
            
            <div id="leaderboard">
                <h3>üèÜ B·∫£ng x·∫øp h·∫°ng:</h3>
                <div id="leaderboardList"></div>
            </div>
        </div>
        <canvas id="gameCanvas" width="1000" height="700"></canvas>
        <div id="chatContainer">
            <h4>üí¨ Chat</h4>
            <div id="chatMessages"></div>
            <input type="text" id="chatInput" placeholder="Nh·∫≠p tin nh·∫Øn..." maxlength="100" />
            <div id="foodLegend">
                <h4>üçé Lo·∫°i th·ª©c ƒÉn:</h4>
                <div class="food-type"><span style="color: #e74c3c;">üî¥ ƒê·ªè:</span> +1 ƒë·ªô d√†i</div>
                <div class="food-type"><span style="color: #ffffff;">‚ö™ Tr·∫Øng:</span> +10 ƒë·ªô d√†i</div>
                <div class="food-type"><span style="color: #9b59b6;">üü£ T√≠m:</span> TƒÉng t·ªëc 5s</div>
                <div class="food-type"><span style="color: #34495e;">‚ö´ ƒêen:</span> +20 ƒë·ªô d√†i</div>
                <div class="food-type"><span style="color: #95a5a6;">üîò X√°m:</span> Gi·∫£m t·ªëc 80% trong 5s</div>
                <div class="food-type"><span style="color: #FFFF00;">üü° V√†ng:</span> T·∫°o ra 50 th·ª©c ƒÉn</div>
            </div>
        </div>
    </div>
    
    <div id="gameInfo">
        <div>Ng∆∞·ªùi ch∆°i: <span id="playerCount">0</span></div>
        <div>T·ªïng ƒëi·ªÉm: <span id="myScore">0</span></div>
    </div>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const voteButton = document.getElementById('voteButton');
        const restartButton = document.getElementById('restartButton');
        const statusDiv = document.getElementById('status');
        const playerCountSpan = document.getElementById('playerCount');
        const myScoreSpan = document.getElementById('myScore');
        const playersDiv = document.getElementById('players');
        const leaderboardList = document.getElementById('leaderboardList');
        const connectionStatus = document.getElementById('connectionStatus');
        const nameModal = document.getElementById('nameModal');
        const nameInput = document.getElementById('nameInput');
        const joinButton = document.getElementById('joinButton');
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const voteStatus = document.getElementById('voteStatus');
        const voteCount = document.getElementById('voteCount');
        const totalPlayers = document.getElementById('totalPlayers');
        const votesNeeded = document.getElementById('votesNeeded');
        
        let socket = null;
        let myPlayerId = null;
        let myPlayerName = '';
        let gameState = null;
        
        // Snake colors for different players
        const colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', 
            '#9b59b6', '#1abc9c', '#e67e22', '#34495e'
        ];
        
        function connectWebSocket() {
            // Connect to same host and port as HTTP server
            const host = window.location.hostname;
            const port = window.location.port || '666';
            const wsUrl = `ws://${host}:${port}`;
            
            console.log('Connecting to WebSocket:', wsUrl);
            console.log('Player name:', myPlayerName);
            
            socket = new WebSocket(wsUrl);
            
            socket.onopen = function() {
                console.log('K·∫øt n·ªëi WebSocket th√†nh c√¥ng t·ªõi:', wsUrl);
                connectionStatus.textContent = 'ƒê√£ k·∫øt n·ªëi';
                connectionStatus.className = 'connected';
                statusDiv.textContent = 'ƒê√£ k·∫øt n·ªëi! Ch·ªù ng∆∞·ªùi ch∆°i kh√°c...';
                
                // Send join message with player name
                const joinMessage = {
                    type: 'join',
                    name: myPlayerName
                };
                console.log('Sending join message:', joinMessage);
                socket.send(JSON.stringify(joinMessage));
            };
            
            socket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                
                if (data.type === 'init') {
                    myPlayerId = data.player_id;
                    gameState = data.game_state;
                    updateUI();
                } else if (data.type === 'join_rejected') {
                    // Player cannot join because game is running
                    alert(data.reason);
                    statusDiv.textContent = data.reason;
                    statusDiv.style.color = '#e74c3c';
                    // Show name modal again
                    nameModal.style.display = 'flex';
                    nameInput.value = '';
                    nameInput.focus();
                } else if (data.type === 'game_state') {
                    gameState = data.game_state;
                    updateUI();
                } else if (data.type === 'vote_status') {
                    updateVoteUI(data.vote_status, data.votes);
                } else if (data.type === 'vote_needed') {
                    updateVoteUI(data.vote_status, {});
                } else if (data.type === 'chat') {
                    addChatMessage(data.player_name, data.message);
                } else if (data.type === 'system') {
                    addSystemMessage(data.message);
                }
            };
            
            socket.onclose = function() {
                console.log('WebSocket ƒë√£ ƒë√≥ng');
                connectionStatus.textContent = 'M·∫•t k·∫øt n·ªëi';
                connectionStatus.className = 'disconnected';
                statusDiv.textContent = 'M·∫•t k·∫øt n·ªëi! ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i...';
                
                // Th·ª≠ k·∫øt n·ªëi l·∫°i sau 3 gi√¢y
                setTimeout(connectWebSocket, 3000);
            };
            
            socket.onerror = function(error) {
                console.error('L·ªói WebSocket:', error);
                connectionStatus.textContent = 'L·ªói k·∫øt n·ªëi';
                connectionStatus.className = 'disconnected';
            };
        }
        
        function updateUI() {
            if (!gameState) return;
            
            playerCountSpan.textContent = gameState.player_count;
            
            // Update my score
            const mySnake = gameState.snakes.find(s => s.player_id === myPlayerId);
            if (mySnake) {
                const currentScore = mySnake.score > 0 ? ` (${mySnake.score})` : '';
                myScoreSpan.textContent = `${mySnake.total_score}${currentScore}`;
            }
            
            // Update buttons and voting
            if (gameState.game_started) {
                voteButton.style.display = 'none';
                voteStatus.style.display = 'none';
                startButton.style.display = 'none';
                if (!gameState.game_running) {
                    restartButton.style.display = 'inline-block';
                } else {
                    restartButton.style.display = 'none';
                }
            } else {
                // Show voting interface
                voteButton.style.display = 'inline-block';
                voteStatus.style.display = 'block';
                startButton.style.display = 'none';
                restartButton.style.display = 'none';
                
                // Enable/disable vote button
                const hasVoted = gameState.votes && gameState.votes[myPlayerId];
                voteButton.disabled = hasVoted || gameState.player_count === 0;
                voteButton.textContent = hasVoted ? 'ƒê√£ vote ‚úì' : 'Vote ƒë·ªÉ b·∫Øt ƒë·∫ßu';
                
                // Update vote status
                if (gameState.vote_status) {
                    voteCount.textContent = gameState.vote_status.voted_count;
                    totalPlayers.textContent = gameState.vote_status.total_players;
                    votesNeeded.textContent = gameState.vote_status.votes_needed;
                }
            }
            
            // Update status
            if (!gameState.game_started) {
                if (gameState.player_count === 0) {
                    statusDiv.textContent = 'Ch·ªù ng∆∞·ªùi ch∆°i...';
                } else if (gameState.vote_status && gameState.vote_status.votes_needed > 0) {
                    statusDiv.textContent = `C·∫ßn ${gameState.vote_status.votes_needed} vote n·ªØa ƒë·ªÉ b·∫Øt ƒë·∫ßu game`;
                } else {
                    statusDiv.textContent = 'ƒê·ªß vote! Game s·∫Ω b·∫Øt ƒë·∫ßu...';
                }
            } else if (gameState.game_running) {
                statusDiv.textContent = 'Game ƒëang ch·∫°y!';
                statusDiv.style.color = '#2ecc71';
            } else {
                const aliveSnakes = gameState.snakes.filter(s => s.alive);
                if (aliveSnakes.length === 1) {
                    const winner = aliveSnakes[0];
                    if (winner.player_id === myPlayerId) {
                        statusDiv.textContent = 'Ch√∫c m·ª´ng! B·∫°n th·∫Øng! üéâ';
                        statusDiv.style.color = '#2ecc71';
                    } else {
                        statusDiv.textContent = `Game k·∫øt th√∫c! Ng∆∞·ªùi th·∫Øng: ${winner.player_name}`;
                        statusDiv.style.color = '#e74c3c';
                    }
                } else {
                    statusDiv.textContent = 'Game k·∫øt th√∫c!';
                    statusDiv.style.color = '#e74c3c';
                }
            }
            
            // Update player list
            playersDiv.innerHTML = '';
            gameState.snakes.forEach((snake, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.style.color = colors[index % colors.length];
                const status = snake.alive ? 'üêç' : 'üíÄ';
                const isMe = snake.player_id === myPlayerId ? ' (B·∫°n)' : '';
                const displayName = snake.player_name || snake.player_id;
                const hasVoted = gameState.votes && gameState.votes[snake.player_id];
                const voteCheck = !gameState.game_started && hasVoted ? ' ‚úì' : '';
                const speedBoost = snake.has_speed_boost ? ' ‚ö°' : '';
                const speedReduction = snake.has_speed_reduction ? ' üêå' : '';
                playerDiv.textContent = `${status} ${displayName}${voteCheck}${isMe} - ${snake.score} ƒëi·ªÉm${speedBoost}${speedReduction}`;
                playersDiv.appendChild(playerDiv);
            });
            
            // Update leaderboard
            updateLeaderboard();
            
            // Draw game
            draw();
        }
        
        function updateLeaderboard() {
            if (!gameState) return;
            
            const leaderboardList = document.getElementById('leaderboardList');
            leaderboardList.innerHTML = '';
            
            // Sort snakes by total_score first, then by current score
            const sortedSnakes = [...gameState.snakes].sort((a, b) => {
                if (b.total_score !== a.total_score) {
                    return b.total_score - a.total_score;
                }
                return b.score - a.score;
            });
            
            sortedSnakes.forEach((snake, index) => {
                const rankDiv = document.createElement('div');
                const rankIcon = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                const isMe = snake.player_id === myPlayerId ? ' (B·∫°n)' : '';
                const displayName = snake.player_name || snake.player_id;
                const status = snake.alive ? '' : ' üíÄ';
                rankDiv.style.color = colors[gameState.snakes.findIndex(s => s.player_id === snake.player_id) % colors.length];
                
                // Show both current score and total score
                const currentScore = snake.score > 0 ? ` (${snake.score})` : '';
                rankDiv.textContent = `${rankIcon} ${displayName}${isMe} - ${snake.total_score}${currentScore}${status}`;
                leaderboardList.appendChild(rankDiv);
            });
        }
        
        function addChatMessage(playerName, message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message chat-player';
            messageDiv.innerHTML = `<strong>${playerName}:</strong> ${message}`;
            chatMessages.appendChild(messageDiv);
            
            // Limit to 10 messages
            while (chatMessages.children.length > 10) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
            
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function addSystemMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message chat-system';
            messageDiv.textContent = message;
            chatMessages.appendChild(messageDiv);
            
            // Limit to 10 messages
            while (chatMessages.children.length > 10) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
            
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function draw() {
            if (!gameState) return;
            
            // Clear canvas
            ctx.fillStyle = '#0f1419';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 0.5;
            for (let x = 0; x <= canvas.width; x += 20) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += 20) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw food
            gameState.food.forEach(food => {
                let color = '#e74c3c'; // Default red for normal food
                if (food.type === 'white') {
                    color = '#ffffff'; // White food
                } else if (food.type === 'purple') {
                    color = '#9b59b6'; // Purple food
                } else if (food.type === 'black') {
                    color = '#34495e'; // Dark blue-gray food
                } else if (food.type === 'gray') {
                    color = '#95a5a6'; // Gray food
                } else if (food.type === 'gold') {
                    color = '#FFD700'; // Gold food
                } else if (food.type === 'yellow') {
                    color = '#FFFF00'; // Yellow food
                }
                
                ctx.fillStyle = color;
                ctx.fillRect(food.x, food.y, 20, 20);
                // Add glow effect
                ctx.shadowBlur = 10;
                ctx.shadowColor = color;
                ctx.fillRect(food.x + 2, food.y + 2, 16, 16);
                ctx.shadowBlur = 0;
            });
            
            // Draw deadly gold food (if present)
            if (gameState.deadly_gold_food) {
                gameState.deadly_gold_food.forEach(deadlyFood => {
                    ctx.fillStyle = '#FF8C00'; // Dark orange for deadly gold
                    ctx.fillRect(deadlyFood.x, deadlyFood.y, 20, 20);
                    // Add danger glow effect
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#FF4500'; // Red-orange glow
                    ctx.fillRect(deadlyFood.x + 2, deadlyFood.y + 2, 16, 16);
                    ctx.shadowBlur = 0;
                    
                    // Add skull symbol for deadly food
                    ctx.fillStyle = '#000000';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üíÄ', deadlyFood.x + 10, deadlyFood.y + 15);
                });
            }
            
            // Draw snakes
            gameState.snakes.forEach((snake, index) => {
                if (snake.body.length === 0) return;
                
                const color = colors[index % colors.length];
                const isAlive = snake.alive;
                const isMe = snake.player_id === myPlayerId;
                const hasSpeedBoost = snake.has_speed_boost;
                const hasSpeedReduction = snake.has_speed_reduction;
                
                snake.body.forEach((segment, segIndex) => {
                    if (segIndex === 0) {
                        // Snake head
                        ctx.fillStyle = isAlive ? color : '#7f8c8d';
                        ctx.fillRect(segment[0], segment[1], 20, 20);
                        
                        // Head border (golden for own snake, white for speed boost, red for speed reduction)
                        if (isMe) {
                            ctx.strokeStyle = '#f1c40f';
                            ctx.lineWidth = 3;
                        } else if (hasSpeedBoost) {
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 3;
                        } else if (hasSpeedReduction) {
                            ctx.strokeStyle = '#e74c3c';
                            ctx.lineWidth = 3;
                        } else {
                            ctx.strokeStyle = '#2c3e50';
                            ctx.lineWidth = 2;
                        }
                        ctx.strokeRect(segment[0], segment[1], 20, 20);
                        
                        // Speed boost glow effect
                        if (hasSpeedBoost && isAlive) {
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = '#ffffff';
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(segment[0] - 2, segment[1] - 2, 24, 24);
                            ctx.shadowBlur = 0;
                        }
                        
                        // Speed reduction effect (dark red glow)
                        if (hasSpeedReduction && isAlive) {
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = '#e74c3c';
                            ctx.strokeStyle = '#e74c3c';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(segment[0] - 1, segment[1] - 1, 22, 22);
                            ctx.shadowBlur = 0;
                        }
                        
                        // Eyes
                        if (isAlive) {
                            ctx.fillStyle = '#2c3e50';
                            ctx.fillRect(segment[0] + 5, segment[1] + 5, 3, 3);
                            ctx.fillRect(segment[0] + 12, segment[1] + 5, 3, 3);
                        }
                    } else {
                        // Snake body
                        const alpha = isAlive ? Math.max(0.3, 1 - segIndex * 0.1) : 0.3;
                        ctx.fillStyle = isAlive ? color + Math.round(alpha * 255).toString(16).padStart(2, '0') : '#7f8c8d80';
                        ctx.fillRect(segment[0], segment[1], 20, 20);
                        
                        // Speed boost glow on body
                        if (hasSpeedBoost && isAlive && segIndex < 3) {
                            ctx.shadowBlur = 5;
                            ctx.shadowColor = '#ffffff';
                            ctx.fillRect(segment[0], segment[1], 20, 20);
                            ctx.shadowBlur = 0;
                        }
                        
                        ctx.strokeStyle = '#2c3e50';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(segment[0], segment[1], 20, 20);
                    }
                });
            });
        }
        
        function updateVoteUI(voteStatus, votes) {
            voteCount.textContent = voteStatus.voted_count;
            totalPlayers.textContent = voteStatus.total_players;
            votesNeeded.textContent = voteStatus.votes_needed;
            
            // Update vote button
            const hasVoted = votes && votes[myPlayerId];
            voteButton.disabled = hasVoted;
            voteButton.textContent = hasVoted ? 'ƒê√£ vote ‚úì' : 'Vote ƒë·ªÉ b·∫Øt ƒë·∫ßu';
        }
        
        // Event handlers
        voteButton.addEventListener('click', function() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    type: 'vote_start'
                }));
            }
        });
        
        startButton.addEventListener('click', function() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    type: 'start_game'
                }));
            }
        });
        
        restartButton.addEventListener('click', function() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    type: 'restart_game'
                }));
            }
        });
        
        // Name input handlers
        joinButton.addEventListener('click', function() {
            const name = nameInput.value.trim();
            console.log('Join button clicked, name:', name);
            if (name.length > 0) {
                myPlayerName = name;
                console.log('Player name set to:', myPlayerName);
                nameModal.style.display = 'none';
                connectWebSocket();
            } else {
                console.log('Name is empty, cannot join');
                alert('Vui l√≤ng nh·∫≠p t√™n!');
            }
        });
        
        nameInput.addEventListener('keypress', function(event) {
            console.log('Key pressed:', event.key);
            if (event.key === 'Enter') {
                console.log('Enter key pressed, triggering join');
                joinButton.click();
            }
        });
        
        // Chat handlers
        chatInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                const message = chatInput.value.trim();
                if (message.length > 0 && socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({
                        type: 'chat',
                        message: message
                    }));
                    chatInput.value = '';
                }
            }
        });
        
        // Keyboard controls
        document.addEventListener('keydown', function(event) {
            if (!socket || socket.readyState !== WebSocket.OPEN || !gameState || !gameState.game_running) {
                return;
            }
            
            // Get current player's snake
            const mySnake = gameState.snakes.find(s => s.player_id === myPlayerId);
            if (!mySnake || !mySnake.alive) {
                return;
            }
            
            let direction = null;
            
            switch(event.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    direction = 'up';
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    direction = 'down';
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    direction = 'left';
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    direction = 'right';
                    break;
            }
            
            if (direction) {
                // Prevent reverse direction on client side
                const opposite = {
                    'up': 'down',
                    'down': 'up',
                    'left': 'right',
                    'right': 'left'
                };
                
                // Additional check: if snake has more than 1 segment, 
                // don't allow direction that would immediately hit the second segment
                let canChangeDirection = true;
                if (mySnake.body.length > 1) {
                    const head = mySnake.body[0];
                    const second = mySnake.body[1];
                    
                    // Calculate where the head would be after the move
                    let newHead = null;
                    if (direction === 'up') {
                        newHead = [head[0], head[1] - 20];
                    } else if (direction === 'down') {
                        newHead = [head[0], head[1] + 20];
                    } else if (direction === 'left') {
                        newHead = [head[0] - 20, head[1]];
                    } else if (direction === 'right') {
                        newHead = [head[0] + 20, head[1]];
                    }
                    
                    // Don't allow if new head would be on second segment
                    if (newHead && newHead[0] === second[0] && newHead[1] === second[1]) {
                        canChangeDirection = false;
                    }
                }
                
                // Only send if direction is valid
                if (direction !== opposite[mySnake.direction] && canChangeDirection) {
                    event.preventDefault();
                    socket.send(JSON.stringify({
                        type: 'move',
                        direction: direction
                    }));
                }
            }
        });
        
        // Focus name input when page loads
        nameInput.focus();
    </script>
</body>
</html>
